<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>回调函数</title>
    <link href="/2021/09/20/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <url>/2021/09/20/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>definition: A callback is a function that is passed as an argument to another function and is executed after its parent function has completed.</p></blockquote><span id="more"></span><ul><li><p>同步编程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">  <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>      startBoil();<br>      coolDown();<br>      drinkSoap();<br>  &#125;).start();<br>  <br>  # 第一步 -- 炖汤<br>  # 第二步 -- 汤凉一会<br># 第三步 -- 喝汤<br>  <br></code></pre></td></tr></table></figure></li></ul><p>以上的三个操作要转换成异步调用模式，最直观的解决方案就是用<strong>回调函数</strong>。什么是回调函数呢？</p><p>即一个函数作为另一个函数的参数</p><blockquote><p>推荐阅读 </p><ul><li><a href="#js%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88">js中的函数指针</a></li></ul></blockquote><ul><li><p>异步回调</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">startBoil(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;炖好了，撒点盐&quot;</span>)<br>    coolDown(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;现在可以喝了&quot;</span>)<br>        drinkSoap(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params"></span>) </span>&#123;<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;嗝~~&quot;</span>)<br>        &#125;)<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><p>以上写法虽然避免了线程间上下文切换的问题，但这样写异步代码，写着写着屏幕就不够宽了。嵌套回调越来越深，变成了回调地狱。</p><p>拓展</p><ul><li><h5 id="js的函数指针"><a href="#js的函数指针" class="headerlink" title="js的函数指针"></a>js的函数指针</h5></li></ul><blockquote><p>函数名就是函数指针,函数名指向函数主体,对于function hello(){}这个函数，hello即代表函数的主体，而hello()则是函数实现的结果。</p></blockquote><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
    
    <tags>
      
      <tag>小知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java输入输出</title>
    <link href="/2021/09/19/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <url>/2021/09/19/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Scanner 在数据较多的时候输入输出较慢，所以采用 BufferedReader 方法</p></blockquote> <span id="more"></span><ul><li>Scanner </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner s1 = <span class="hljs-keyword">new</span> Scanner(System.in);     <span class="hljs-comment">// 创建输入对象</span><br>        Scanner s2 = <span class="hljs-keyword">new</span> Scanner(System.in);     <span class="hljs-comment">// 创建输入对象</span><br><br>        String str = s1.next();                  <span class="hljs-comment">// 输入一个字符串，空格或回车换行时就不继续读了</span><br>        String line = s2.nextLine();             <span class="hljs-comment">// 输入一行字符串</span><br><span class="hljs-comment">//        int num1 = s.nextInt();                 // 输入一个整数</span><br><span class="hljs-comment">//        double num2 = s.nextDouble();           // 输入一个小数</span><br>        System.out.println(str + <span class="hljs-string">&quot; &quot;</span> + line);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>BufferedReader </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        BufferedReader in = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in)); <span class="hljs-comment">// 输入</span><br>        String line = in.readLine();<br>        System.out.println(line);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2021/09/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/09/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>正则表达式快速高效，对于某些内容的提取有非常明显的效果，而编程语言的正则大都相同，等于是学一个知识通一类知识，简直不要太爽。</p></blockquote><span id="more"></span><p>A <strong>regular expression</strong> shortened as <strong>regex</strong> or <strong>regexp</strong>; also referred to as <strong>rational expression</strong>is a sequence of characters that specifies a <em>search pattern</em>. Usually such patterns are used by string-searching algorithms for “find” or “find and replace” operations on strings, or for input validation. It is a technique developed in theoretical computer science and formal language theory.</p>]]></content>
    
    
    
    <tags>
      
      <tag>小知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ADBlock插件实现原理</title>
    <link href="/2021/09/19/ADBlock%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2021/09/19/ADBlock%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://adblockplus.org/zh_CN/about">Adblock</a> Plus 是一个可让您自定义您的网络体验的免费扩展程序。您可以屏蔽烦人的广告、防止跟踪等等。它适用于所有主要的桌面浏览器和移动设备。</p></blockquote><span id="more"></span><p>文章推荐阅读：<a href="https://www.jianshu.com/p/f2e1dc62cc82">ADBlock的实现原理</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>chrome插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内网穿透</title>
    <link href="/2021/09/18/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <url>/2021/09/18/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>内网穿透：对于内网来说，其不是不能主动访问公网端口，而是不能反过来有效的被公网访问。内网穿透的主要思路就是利用这一点，让在内网的节点主动访问一个拥有公网IP地址的服务器，并由中间服务器搭桥，打通经过该服务器从其他主机到NAT之后节点的隧道。</p></blockquote><more>]]></content>
    
    
    
    <tags>
      
      <tag>小知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
